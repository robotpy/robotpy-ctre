---
sim_extra: |
  from .ctre_sim_enums import ControlMode, FeedbackDevice
  
  _feedback2key = {
     FeedbackDevice.QuadEncoder: 'quad_',
     FeedbackDevice.Analog: 'analog_',
     FeedbackDevice.PulseWidthEncodedPosition: 'pulse_width_',
   }
    
c_MotController_Create1:
  internal: true
  code: |
    self.create_called = True
    
    deviceId = baseArbId & 0xFFFF
    deviceType = (baseArbId >> 16) & 0xFFFF
    if deviceType == 0x0104:
      deviceType = 'victorspx'
    elif deviceType == 0x0204:
      deviceType = 'talonsrx'
    else:
      raise ValueError("Invalid device id `%s`" % deviceType)
      
    self._deviceId = deviceId
    
    self.hal_data = NotifyDict({
      'type': deviceType,
      'sim_display': False, # used in sim
      
      'sensor_phase': False,
      'temp': 0.0,
      'bus_voltage': 12.0,
      'output_current': 0.1,
      
      'inverted': False,
      'last_error': ErrorCode.OK,
      
      # Configuration
      'voltage_comp_saturation': 0,
      'voltage_measurement_filter': 0,
      'voltage_comp_enabled': False,
      
      'current_limit_peak': 0,
      'current_peak_duration': 0,
      'current_limit_continuous': 0,
      'current_limit_enabled': False,
      
      'peak_fwd_output': 0.0,
      'peak_rev_output': 0.0,
      'nom_fwd_output': 0.0,
      'nom_rev_output': 0.0,
      'neutral_deadband': 0.0,
      
      'sensor_term': (0, 0),
      
      'vel_measurement_period': 0,
      'vel_measurement_window': 0,
      
      # Quadrature encoder data
      'quad_position': 0,
      'quad_velocity': 0,
      'quad_pin_a': 0,
      'quad_pin_b': 0,
      'quad_pin_idx': 0,
      
      # Analog position data
      'analog_position': 0,
      'analog_velocity': 0,
      'analog_in_raw': 0,
      'analog_in': 0,
      
      # Pulse width position data
      'pulse_width_position': 0,
      'pulse_width_velocity': 0,
      'pulse_width_rise_to_rise': 0,
      'pulse_width_rise_to_fall': 0,
      
      # Soft limits
      'soft_limit_usable': True,
      'soft_limit_for': 0,
      'soft_limit_for_enable': False,
      'soft_limit_rev': 0,
      'soft_limit_rev_enable': False,
      
      # Hard limits
      'limit_switch_usable': True,
      'limit_switch_closed_for': False,
      'limit_switch_closed_rev': False,
      
      # These two values are set when the set()/setDemand() functions are called
      'control_mode': 0,
      'value': 0,
      
      'neutral_mode': self.NeutralMode.EEPROMSetting,
      
      'follow_target': 0,
      'followers': set(),
      'open_loop_ramp': 0.0,
      'closed_loop_ramp': 0.0,
      
      # PIDF parameters
      'profile0_p': 0.0,
      'profile0_i': 0.0,
      'profile0_d': 0.0,
      'profile0_f': 0.0,
      'profile0_izone': 0.0,
      'profile0_allowableError': 0,
      'profile0_max_iaccum': 0.0,
      
      'profile1_p': 0.0,
      'profile1_i': 0.0,
      'profile1_d': 0.0,
      'profile1_f': 0.0,
      'profile1_izone': 0.0,
      'profile1_allowableError': 0,
      'profile1_max_iaccum': 0.0,
      
      # PIDF stored computations
      # -> 0/1 refers to pidIdx
      'pid0_iaccum': 0.0,
      'pid0_error': 0,
      'pid0_errorDerivative': 0.0,
      'pid0_feedback': FeedbackDevice.None_,
      
      'pid1_iaccum': 0.0,
      'pid1_error': 0,
      'pid1_errorDerivative': 0.0,
      'pid1_feedback': FeedbackDevice.None_,
      
      # slotIdx
      'profile_slot_select': 0,
      # pidIdx
      'pid_slot_select': 0,
      
      
    })
  
    hal_data['CAN'][deviceId] = self.hal_data
    
c_MotController_GetDeviceNumber:
  code: |
    retval = self._deviceId
c_MotController_GetDescription:
  ignore: true # TODO`
  code: |
    raise NotImplementedError
c_MotController_SetDemand:
  code: |
    if self.hal_data['control_mode'] == ControlMode.Follower and mode != ControlMode.Follower:
        follow_target = self.hal_data['follow_target']
        hal_data['CAN'][follow_target]['followers'].remove(self._deviceId)
    self.hal_data['control_mode'] = mode
    if mode == ControlMode.PercentOutput:
        self.hal_data['value'] = demand0 / 1023.
    elif mode == ControlMode.Follower:
        follow_target = demand0 & 0xFF
        assert follow_target != self._deviceId
        self.hal_data['follow_target'] = follow_target
        hal_data['CAN'][follow_target]['followers'].add(self._deviceId)
        self.hal_data['value'] = hal_data['CAN'][follow_target]['value']
    else:
        self.hal_data['value'] = demand0

    for follower_id in self.hal_data['followers']:
        hal_data['CAN'][follower_id]['value'] = self.hal_data['value']
c_MotController_SetNeutralMode:
  set: neutral_mode
  doc: |
    Sets the mode of operation during neutral throttle output.
    
    :param neutralMode:
        The desired mode of operation when the Controller output
        throttle is neutral (ie brake/coast)
c_MotController_SetSensorPhase:
  set: sensor_phase
  doc: |
    Sets the phase of the sensor. Use when controller forward/reverse output
    doesn't correlate to appropriate forward/reverse reading of sensor.

    Pick a value so that positive PercentOutput yields a positive change in sensor.
    After setting this, user can freely call SetInvert() with any value.
    
    :param PhaseSensor:
        Indicates whether to invert the phase of the sensor.
c_MotController_SetInverted:
  set: inverted
c_MotController_ConfigOpenLoopRamp:
  set: open_loop_ramp
  doc: |
    Configures the open-loop ramp rate of throttle output.
    
    :param secondsFromNeutralToFull:
        Minimum desired time to go from neutral to full throttle. A
        value of '0' will disable the ramp.
    :param timeoutMs:
        Timeout value in ms. Function will generate error if config is
        not successful within timeout.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigClosedLoopRamp:
  set: closed_loop_ramp
  doc: |
    Configures the closed-loop ramp rate of throttle output.
    
    :param secondsFromNeutralToFull:
        Minimum desired time to go from neutral to full throttle. A
        value of '0' will disable the ramp.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigPeakOutputForward:
  set: peak_fwd_output
  doc: |
    Configures the forward peak output percentage.
    
    :param percentOut:
        Desired peak output percentage [0,1].
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigPeakOutputReverse:
  set: peak_rev_output
  doc: |
    Configures the reverse peak output percentage.
    
    :param percentOut:
        Desired peak output percentage.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigNominalOutputForward:
  set: nom_fwd_output
  doc: |
    Configures the forward nominal output percentage.
    
    :param percentOut:
        Nominal (minimum) percent output [0,+1].
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigNominalOutputReverse:
  set: nom_rev_output
  doc: |
    Configures the reverse nominal output percentage.
    
    :param percentOut:
        Nominal (minimum) percent output [-1,0].
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigNeutralDeadband:
  set: neutral_deadband
  doc: |
    Configures the output deadband percentage.
    
    :param percentDeadband:
        Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
        Pass 0.04 for 4% (factory default).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigVoltageCompSaturation:
  set: voltage_comp_saturation
  doc: |
    Configures the Voltage Compensation saturation voltage.
    
    :param voltage:
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigVoltageMeasurementFilter:
  set: voltage_measurement_filter
  doc: |
    Configures the voltage measurement filter.
    
    :param filterWindowSamples:
        Number of samples in the rolling average of voltage
        measurement.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_EnableVoltageCompensation:
  set: voltage_comp_enabled
  doc: |
    Enables voltage compensation. If enabled, voltage compensation works in
    all control modes.
    
    :param enable:
        Enable state of voltage compensation.
c_MotController_GetBusVoltage:
  get: bus_voltage
  doc: |
    Gets the bus voltage seen by the device.
    
    :returns: The bus voltage value (in volts).
c_MotController_GetMotorOutputPercent:
  code: |
    raise NotImplementedError
  doc: |
    Gets the output percentage of the motor controller.
    
    :returns: Output of the motor controller (in percent).
c_MotController_GetOutputCurrent:
  get: output_current
  doc: |
    Gets the output current of the motor controller.
    
    :returns: The output current (in amps).
c_MotController_GetTemperature:
  get: temp
  doc: |
    Gets the temperature of the motor controller.
    
    :returns: Temperature of the motor controller (in 'C)
c_MotController_ConfigSelectedFeedbackSensor:
  code: |
    self.hal_data['pid%d_feedback' % pidIdx] = feedbackDevice
  doc: |
    Select the feedback device for the motor controller.
    Most CTRE CAN motor controllers will support remote sensors over CAN.

    :param feedbackDevice:
        Feedback Device to select.
    :type: feedbackDevice: :class:`.FeedbackDevice` or :class:`.RemoteFeedbackDevice`
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
        See Phoenix-Documentation for how to interpret.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigRemoteFeedbackFilter:
  code: |
    raise NotImplementedError
  doc: |
    Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
    After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
    as a PID source for closed-loop features.

    :param deviceID:
        The CAN ID of the remote sensor device.
    :param remoteSensorSource:
        The remote sensor device and signal type to bind.
    :param remoteOrdinal:
        0 for configuring Remote Sensor 0
        1 for configuring Remote Sensor 1
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigSensorTerm:
  code: |
    self.hal_data['sensor_term'] = (sensorTerm, feedbackDevice)
  doc: |
    Select what sensor term should be bound to switch feedback device.

    Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1

    Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1

    The four terms are specified with this routine.  Then Sensor Sum/Difference
    can be selected for closed-looping.
    
    :param sensorTerm: Which sensor term to bind to a feedback source.
    :param feedbackDevice: The sensor signal to attach to sensorTerm.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_GetSelectedSensorPosition:
  code: |
    retval = 0
    fd = self.hal_data['pid%d_feedback' % pidIdx]
    prefix = _feedback2key.get(fd)
    if prefix is None:
        if fd != FeedbackDevice.None_:
           raise NotImplementedError("getSelectedSensorPosition not implemented for %s" % fd)
    else:
        retval = self.hal_data['%sposition' % prefix]
  doc: |
    Get the selected sensor position.
    
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
        See Phoenix-Documentation for how to interpret.
    :returns: Position of selected sensor (in Raw Sensor Units).
c_MotController_GetSelectedSensorVelocity:
  code: |
    retval = 0
    fd = self.hal_data['pid%d_feedback' % pidIdx]
    prefix = _feedback2key.get(fd)
    if prefix is None:
        if fd != FeedbackDevice.None_:
           raise NotImplementedError("getSelectedSensorVelocity not implemented for %s" % fd)
    else:
        retval = self.hal_data['%svelocity' % prefix]
  doc: |
    Get the selected sensor velocity.
    
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
        See Phoenix-Documentation for how to interpret.
    :returns: selected sensor (in raw sensor units) per 100ms.
c_MotController_SetSelectedSensorPosition:
  code: |
    fd = self.hal_data['pid%d_feedback' % pidIdx]
    prefix = _feedback2key.get(fd)
    if prefix is None:
        if fd != FeedbackDevice.None_:
           raise NotImplementedError("setSelectedSensorPosition not implemented for %s" % fd)
    else:
        self.hal_data['%sposition' % prefix] = sensorPos
  doc: |
    Sets the sensor position to the given value.

    :param sensorPos:
        Position to set for the selected sensor (in raw sensor units).
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_SetControlFramePeriod:
  code: pass
  doc: |
    Sets the period of the given control frame.
    
    :param frame:
        Frame whose period is to be changed.
    :param periodMs:
        Period in ms for the given frame.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_SetStatusFramePeriod:
  code: pass
  doc: |
    Sets the period of the given status frame.

    User ensure CAN Bus utilization is not high.
     
    This setting is not persistent and is lost when device is reset. If this
    is a concern, calling application can use HasReset() to determine if the
    status frame needs to be reconfigured.

    :param frame:
        Frame whose period is to be changed.
    :param periodMs:
        Period in ms for the given frame.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_GetStatusFramePeriod:
  code: |
    raise NotImplementedError
  doc: |
    Gets the period of the given status frame.
    
    :param frame:
        Frame to get the period of.
    :type frame: :class:`.StatusFrame` or :class:`.StatusFrameEnhanced`
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Period of the given status frame.
c_MotController_ConfigVelocityMeasurementPeriod:
  set: vel_measurement_period
  doc: |
    Sets the period over which velocity measurements are taken.

    :param period:
        Desired period for the velocity measurement. see :class:`.VelocityMeasPeriod`
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigVelocityMeasurementWindow:
  set: vel_measurement_window
  doc: |
    Sets the number of velocity samples used in the rolling average velocity
    measurement.

    :param windowSize:
        Number of samples in the rolling average of velocity
        measurement. Valid values are 1,2,4,8,16,32. If another value
        is specified, it will truncate to nearest support value.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigForwardLimitSwitchSource:
  code: |
    raise NotImplementedError
  doc: |
    Configures the forward limit switch for a remote source. For example, a
    CAN motor controller may need to monitor the Limit-F pin of another Talon
    or CANifier.

    :param type:
        Remote limit switch source. User can choose between a remote
        Talon SRX, CANifier, or deactivate the feature.
    :param normalOpenOrClose:
        Setting for normally open, normally closed, or disabled. This
        setting matches the web-based configuration drop down.
    :param deviceID:
        Device ID of remote source (Talon SRX or CANifier device ID).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigReverseLimitSwitchSource:
  code: |
    raise NotImplementedError
  doc: |
    Configures the reverse limit switch for a remote source. For example, a
    CAN motor controller may need to monitor the Limit-R pin of another Talon
    or CANifier.

    :param type:
        Remote limit switch source. User can choose between a remote
        Talon SRX, CANifier, or deactivate the feature.
    :param normalOpenOrClose:
        Setting for normally open, normally closed, or disabled. This
        setting matches the web-based configuration drop down.
    :param deviceID:
        Device ID of remote source (Talon SRX or CANifier device ID).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_OverrideLimitSwitchesEnable:
  set: limit_switch_usable
  doc: |
    Sets the enable state for limit switches.

    :param enable:
        Enable state for limit switches.
c_MotController_ConfigForwardSoftLimitThreshold:
  set: soft_limit_for
  doc: |
    Configures the forward soft limit threhold.

    :param forwardSensorLimit:
        Forward Sensor Position Limit (in raw Sensor Units).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigReverseSoftLimitThreshold:
  set: soft_limit_rev
  doc: |
    Configures the reverse soft limit threshold.

    :param reverseSensorLimit:
        Reverse Sensor Position Limit (in Raw Sensor Units).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigForwardSoftLimitEnable:
  set: soft_limit_for_enable
  doc: |
    Configures the forward soft limit enable.

    :param enable:
        Forward Sensor Position Limit Enable.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigReverseSoftLimitEnable:
  set: soft_limit_rev_enable
  doc: |
    Configures the reverse soft limit enable.

    :param enable:
        Reverse Sensor Position Limit Enable.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_OverrideSoftLimitsEnable:
  set: soft_limit_usable
  doc: |
    Can be used to override-disable the soft limits.
    This function can be used to quickly disable soft limits without
    having to modify the persistent configuration.
    
    :param enable:
        Enable state for soft limit switches.
c_MotController_Config_kP:
  code: |
    self.hal_data['profile%d_p' % slotIdx] = value
  doc: |
    Sets the 'P' constant in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param value:
        Value of the P constant.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_Config_kI:
  code: |
    self.hal_data['profile%d_i' % slotIdx] = value
  doc: |
    Sets the 'I' constant in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param value:
        Value of the I constant.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_Config_kD:
  code: |
    self.hal_data['profile%d_d' % slotIdx] = value
  doc: |
    Sets the 'D' constant in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param value:
        Value of the D constant.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_Config_kF:
  code: |
    self.hal_data['profile%d_f' % slotIdx] = value
  doc: |
    Sets the 'F' constant in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param value:
        Value of the F constant.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_Config_IntegralZone:
  code: |
    self.hal_data['profile%d_izone' % slotIdx] = izone
  doc: |
    Sets the Integral Zone constant in the given parameter slot. If the
    (absolute) closed-loop error is outside of this zone, integral
    accumulator is automatically cleared. This ensures than integral wind up
    events will stop after the sensor gets far enough from its target.

    :param slotIdx:
        Parameter slot for the constant.
    :param izone:
        Value of the Integral Zone constant. (closed loop error units X 1ms).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigAllowableClosedloopError:
  code: |
    self.hal_data['profile%d_allowableError' % slotIdx] = allowableClosedLoopError
  doc: |
    Sets the allowable closed-loop error in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param allowableClosedLoopError:
        Value of the allowable closed-loop error.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigMaxIntegralAccumulator:
  code: |
    self.hal_data['profile%d_max_iaccum' % slotIdx] = iaccum
  doc: |
    Sets the maximum integral accumulator in the given parameter slot.

    :param slotIdx:
        Parameter slot for the constant.
    :param iaccum:
        Value to set for the integral accumulator (closed loop error
        units X 1ms).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_SetIntegralAccumulator:
  code: |
    self.hal_data['pid%d_iaccum' % pidIdx] = iaccum
  doc: |
    Sets the integral accumulator. Typically this is used to clear/zero the
    integral accumulator, however some use cases may require seeding the
    accumulator for a faster response.
    
    :param iaccum:
        Value to set for the integral accumulator (closed loop error
        units X 1ms).
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_GetClosedLoopError:
  code: |
    retval = self.hal_data['pid%d_error' % pidIdx]
  doc: |
    Gets the closed-loop error.  The units depend on which control mode is in
    use. See Phoenix-Documentation information on units.

    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :returns: Closed-loop error value.
c_MotController_GetIntegralAccumulator:
  code: |
    retval = self.hal_data['pid%d_iaccum' % pidIdx]
  doc: |
    Gets the iaccum value.

    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :returns: Integral accumulator value.
c_MotController_GetErrorDerivative:
  code: |
    retval = self.hal_data['pid%d_errorDerivative' % pidIdx]
  doc: |
    Gets the derivative of the closed-loop error.
    
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :returns: The error derivative value.
c_MotController_SelectProfileSlot:
  code: |
    self.hal_data['profile_slot_select'] = slotIdx
    self.hal_data['pid_slot_select'] = pidIdx
  doc: |
    Selects which profile slot to use for closed-loop control.

    :param slotIdx:
        Profile slot to select.
    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
c_MotController_GetActiveTrajectoryPosition:
  code: |
    raise NotImplementedError
  doc: |
    Gets the active trajectory target position using
    MotionMagic/MotionProfile control modes.
    
    :returns: The Active Trajectory Position in sensor units.
c_MotController_GetActiveTrajectoryVelocity:
  code: |
    raise NotImplementedError
  doc: |
    Gets the active trajectory target velocity using
    MotionMagic/MotionProfile control modes.
    
    :returns: The Active Trajectory Velocity in sensor units per 100ms.
c_MotController_GetActiveTrajectoryHeading:
  code: |
    raise NotImplementedError
  doc: |
    Gets the active trajectory target heading using
    MotionMagicArc/MotionProfileArc control modes.
    
    :returns: The Active Trajectory Heading in degreees.
c_MotController_GetActiveTrajectoryAll:
  code: |
    raise NotImplementedError
c_MotController_ConfigMotionCruiseVelocity:
  code: |
    raise NotImplementedError
  doc: |
    Sets the Motion Magic Cruise Velocity.  This is the peak target velocity
    that the motion magic curve generator can use.
    
    :param sensorUnitsPer100ms:
        Motion Magic Cruise Velocity (in raw Sensor Units per 100 ms).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigMotionAcceleration:
  code: |
    raise NotImplementedError
  doc: |
    Sets the Motion Magic Acceleration. This is the target acceleration that
    the motion magic curve generator can use.
    
    :param sensorUnitsPer100msPerSec:
        Motion Magic Acceleration (in raw sensor units per 100 ms per
        second).
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ClearMotionProfileTrajectories:
  code: |
    raise NotImplementedError
  doc: |
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).
c_MotController_GetMotionProfileTopLevelBufferCount:
  code: |
    raise NotImplementedError
  doc: |
    Retrieve just the buffer count for the api-level (top) buffer. This
    routine performs no CAN or data structure lookups, so its fast and ideal
    if caller needs to quickly poll the progress of trajectory points being
    emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.
    
    :returns: number of trajectory points in the top buffer.
c_MotController_PushMotionProfileTrajectory:
  internal: true
  code: |
    raise NotImplementedError
  doc: |
    Push another trajectory point into the top level buffer (which is emptied
    into the motor controller's bottom buffer as room allows).

    :param trajPt:
        to push into buffer.

        The members should be filled in with these values...
        
        targPos:  servo position in sensor units.
        targVel:  velocity to feed-forward in sensor units
        per 100ms.
        profileSlotSelect  which slot to pull PIDF gains from.  Currently
        supports 0,1,2,3.
        isLastPoint  set to nonzero to signal motor controller to keep processing this
        trajectory point, instead of jumping to the next one
        when timeDurMs expires.  Otherwise MP executer will
        eventually see an empty buffer after the last point
        expires, causing it to assert the IsUnderRun flag.
        However this may be desired if calling application
        never wants to terminate the MP.
        zeroPos  set to nonzero to signal motor controller to "zero" the selected
        position sensor before executing this trajectory point.
        Typically the first point should have this set only thus
        allowing the remainder of the MP positions to be relative to
        zero.
    :returns:
        CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
        full due to kMotionProfileTopBufferCapacity.
c_MotController_PushMotionProfileTrajectory_2:
  internal: true
  code: |
    raise NotImplementedError
c_MotController_IsMotionProfileTopLevelBufferFull:
  code: |
    raise NotImplementedError
  doc: |
    Retrieve just the buffer full for the api-level (top) buffer. This
    routine performs no CAN or data structure lookups, so its fast and ideal
    if caller needs to quickly poll. Otherwise just use
    GetMotionProfileStatus.
    
    :returns: number of trajectory points in the top buffer.
c_MotController_ProcessMotionProfileBuffer:
  code: |
    raise NotImplementedError
  doc: |
    This must be called periodically to funnel the trajectory points from the
    API's top level buffer to the controller's bottom level buffer. Recommendation
    is to call this twice as fast as the execution rate of the motion
    profile. So if MP is running with 20ms trajectory points, try calling
    this routine every 10ms. All motion profile functions are thread-safe
    through the use of a mutex, so there is no harm in having the caller
    utilize threading.
c_MotController_GetMotionProfileStatus:
  internal: true
  code: |
    raise NotImplementedError
  doc: |
    Retrieve all status information.
    For best performance, Caller can snapshot all status information regarding the
    motion profile executer.
    
    :param statusToFill:
        Caller supplied object to fill.
    
        The members are filled, as follows...
        
        topBufferRem:   The available empty slots in the trajectory buffer.
        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the
        low-level buffer, allowing the motor controller to act on them.
        
        topBufferRem: The number of points in the top trajectory buffer.
        
        btmBufferCnt: The number of points in the low level controller buffer.
        
        hasUnderrun:    Set if isUnderrun ever gets set.
        Only is cleared by clearMotionProfileHasUnderrun() to ensure
        
        isUnderrun:     This is set if controller needs to shift a point from its buffer into
        the active trajectory point however
        the buffer is empty.
        This gets cleared automatically when is resolved.
        
        activePointValid:   True if the active trajectory point has not empty, false otherwise. The members in activePoint are only valid if this signal is set.
        
        isLast: is set/cleared based on the MP executer's current
        trajectory point's IsLast value.  This assumes
        IsLast was set when PushMotionProfileTrajectory
        was used to insert the currently processed trajectory
        point.
        
        profileSlotSelect: The currently processed trajectory point's
        selected slot.  This can differ in the currently selected slot used
        for Position and Velocity servo modes
        
        outputEnable:       The current output mode of the motion profile
        executer (disabled, enabled, or hold).  When changing the set()
        value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.
c_MotController_GetMotionProfileStatus_2:
  internal: true
  code: |
    raise NotImplementedError
c_MotController_ClearMotionProfileHasUnderrun:
  code: |
    raise NotImplementedError
  doc: |
    Clear the "Has Underrun" flag. Typically this is called after application
    has confirmed an underrun had occured.
    
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ChangeMotionControlFramePeriod:
  code: |
    raise NotImplementedError
  doc: |
    Calling application can opt to speed up the handshaking between the robot
    API and the controller to increase the download rate of the controller's Motion
    Profile. Ideally the period should be no more than half the period of a
    trajectory point.
    
    :param periodMs:
        The transmit period in ms.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigMotionProfileTrajectoryPeriod:
  code: |
    raise NotImplementedError
  doc: |
    When trajectory points are processed in the motion profile executer, the MPE determines
    how long to apply the active trajectory point by summing baseTrajDurationMs with the
    timeDur of the trajectory point (see TrajectoryPoint).
    
    This allows general selection of the execution rate of the points with 1ms resolution,
    while allowing some degree of change from point to point.

    :param baseTrajDurationMs: The base duration time of every trajectory point.
                               This is summed with the trajectory points unique timeDur.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_GetLastError:
  get: last_error
  doc: |
    Gets the last error generated by this object.

    :returns: Last Error Code generated by a function.
c_MotController_GetFirmwareVersion:
  code: |
    retval = 0
  doc: |
    Gets the firmware version of the device.
    
    :returns: Firmware version of device. For example: version 1-dot-2
        is 0x0102.
c_MotController_HasResetOccurred:
  code: |
    retval = False
  doc: |
    :returns: Returns true if the device has reset since last call
c_MotController_ConfigSetCustomParam:
  code: |
    raise NotImplementedError
  doc: |
    Sets the value of a custom parameter. This is for arbitrary use.

    Sometimes it is necessary to save calibration/limit/target information
    in the device. Particularly if the device is part of a subsystem that
    can be replaced.

    :param newValue:
        Value for custom parameter.
    :param paramIndex:
        Index of custom parameter [0,1].
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigGetCustomParam:
  code: |
    raise NotImplementedError
  doc: |
    Gets the value of a custom parameter.

    :param paramIndex:
        Index of custom parameter [0,1].
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Value of the custom param.
c_MotController_ConfigSetParameter:
  code: |
    raise NotImplementedError
  doc: |
    Sets a parameter.

    :param param:
        Parameter enumeration.
    :param value:
        Value of parameter.
    :param subValue:
        Subvalue for parameter. Maximum value of 255.
    :param ordinal:
        Ordinal of parameter.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.
    :returns: Error Code generated by function. 0 indicates no error.
c_MotController_ConfigGetParameter:
  code: |
    raise NotImplementedError
  doc: |
    Gets a parameter.

    :param param:
        Parameter enumeration.
    :param ordinal:
        Ordinal of parameter.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for
        config success and report an error if it times out.
        If zero, no blocking or checking is performed.

    :returns: Value of parameter.
c_MotController_ConfigPeakCurrentLimit:
  set: current_limit_peak
  doc: |
    Configure the peak allowable current (when current limit is enabled).

    Current limit is activated when current exceeds the peak limit for longer
    than the peak duration. Then software will limit to the continuous limit.
    This ensures current limiting while allowing for momentary excess current
    events.

    For simpler current-limiting (single threshold) use
    ConfigContinuousCurrentLimit() and set the peak to zero:
    ConfigPeakCurrentLimit(0).

    Not available on the Victor SPX

    :param amps:
        Amperes to limit.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
c_MotController_ConfigPeakCurrentDuration:
  set: current_peak_duration
  doc: |
    Configure the peak allowable duration (when current limit is enabled).
    
    Current limit is activated when current exceeds the peak limit for longer
    than the peak duration. Then software will limit to the continuous limit.
    This ensures current limiting while allowing for momentary excess current
    events.
    
    For simpler current-limiting (single threshold) use
    ConfigContinuousCurrentLimit() and set the peak to zero:
    ConfigPeakCurrentLimit(0).

    Not available on the Victor SPX
    
    :param milliseconds:
        How long to allow current-draw past peak limit.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
c_MotController_ConfigContinuousCurrentLimit:
  set: current_limit_continuous
  doc: |
    Configure the continuous allowable current-draw (when current limit is
    enabled).
    
    Current limit is activated when current exceeds the peak limit for longer
    than the peak duration. Then software will limit to the continuous limit.
    This ensures current limiting while allowing for momentary excess current
    events.
    
    For simpler current-limiting (single threshold) use
    ConfigContinuousCurrentLimit() and set the peak to zero:
    ConfigPeakCurrentLimit(0).

    Not available on the Victor SPX
    
    :param amps:
        Amperes to limit.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
c_MotController_EnableCurrentLimit:
  set: current_limit_enabled
  doc: |
    Enable or disable Current Limit.
    
    :param enable:
        Enable state of current limit.

    Not available on the Victor SPX

    see :meth:`.configPeakCurrentLimit`, :meth:`.configPeakCurrentDuration`,
    :meth:`.configContinuousCurrentLimit`
c_MotController_SetLastError:
  code: |
    self.hal_data['last_error'] = ErrorCode(error)
c_MotController_GetAnalogIn:
  get: analog_in
  doc: |
    Get the position of whatever is in the analog pin of the Talon,
    regardless of whether it is actually being used for feedback.

    :returns:
        the 24bit analog value. The bottom ten bits is the ADC (0 - 1023)
        on the analog pin of the Talon. The upper 14 bits tracks the
        overflows and underflows (continuous sensor).
c_MotController_SetAnalogPosition:
  set: analog_position
  doc: |
    Sets analog position.

    :param newPosition:
        The new position.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: an ErrorCode.
c_MotController_GetAnalogInRaw:
  get: analog_in_raw
  doc: |
    Get the position of whatever is in the analog pin of the Talon,
    regardless of whether it is actually being used for feedback.

    :returns: the ADC (0 - 1023) on analog pin of the Talon.
c_MotController_GetAnalogInVel:
  get: analog_velocity
  doc: |
    Get the velocity of whatever is in the analog pin of the Talon,
    regardless of whether it is actually being used for feedback.

    :returns: the speed in units per 100ms where 1024 units is one rotation.
c_MotController_GetQuadraturePosition:
  get: quad_position
  doc: |
    Get the quadrature position of the Talon, regardless of whether
    it is actually being used for feedback.

    :returns: Quadrature encoder position
c_MotController_SetQuadraturePosition:
  set: quad_position
  doc: |
    Change the quadrature reported position. Typically this is used to "zero"
    the sensor. This only works with Quadrature sensor. To set the selected
    sensor position regardless of what type it is, see
    SetSelectedSensorPosition in the motor controller class.

    :param newPosition:
        The position value to apply to the sensor.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: error code.
c_MotController_GetQuadratureVelocity:
  get: quad_velocity
  doc: |
    Get the quadrature velocity, regardless of whether
    it is actually being used for feedback.

    :returns: the quadrature encoder velocity
c_MotController_GetPulseWidthPosition:
  get: pulse_width_position
  doc: |
    Gets pulse width position, regardless of whether
    it is actually being used for feedback.

    :returns: the pulse width position.
c_MotController_SetPulseWidthPosition:
  set: pulse_width_position
  doc: |
    Sets pulse width position.

    :param newPosition:
        The position value to apply to the sensor.
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: an ErrorCode
c_MotController_GetPulseWidthVelocity:
  get: pulse_width_velocity
  doc: |
    Gets pulse width velocity, regardless of whether
    it is actually being used for feedback.

    :returns: the pulse width velocity  in units per 100ms (where 4096 units is 1 rotation).
c_MotController_GetPulseWidthRiseToFallUs:
  get: pulse_width_rise_to_fall
  doc: |
    Gets pulse width rise to fall time.

    :returns: the pulse width rise to fall time in microseconds.
c_MotController_GetPulseWidthRiseToRiseUs:
  get: pulse_width_rise_to_rise
  doc: |
    Gets pulse width rise to rise time.

    :returns: the pulse width rise to rise time in microseconds.
c_MotController_GetPinStateQuadA:
  get: quad_pin_a
c_MotController_GetPinStateQuadB:
  get: quad_pin_b
c_MotController_GetPinStateQuadIdx:
  get: quad_pin_idx
c_MotController_IsFwdLimitSwitchClosed:
  code: |
    retval = 1 if self.hal_data['limit_switch_closed_for'] else 0
c_MotController_IsRevLimitSwitchClosed:
  code: |
    retval = 1 if self.hal_data['limit_switch_closed_rev'] else 0
c_MotController_GetFaults:
  code: |
    raise NotImplementedError
c_MotController_GetStickyFaults:
  code: |
    raise NotImplementedError
c_MotController_ClearStickyFaults:
  code: |
    raise NotImplementedError
  doc: |
    Clears all sticky faults.
    
    :param timeoutMs:
        Timeout value in ms. If nonzero, function will wait for config
        success and report an error if it times out. If zero, no
        blocking or checking is performed.
    :returns: Last Error Code generated by a function.
c_MotController_SelectDemandType:
  code: pass
  doc: |
    For now this simply updates the CAN signal to the motor controller.
    Future firmware updates will use this to control advanced cascaded loop behavior.
    
    :param value:
c_MotController_SetMPEOutput:
  code: |
    raise NotImplementedError
c_MotController_EnableHeadingHold:
  code: pass
  doc: |
    Enables a future feature called "Heading Hold".
    For now this simply updates the CAN signal to the motor controller.
    Future firmware updates will use this.
    
    :param enable: true/false enable
c_MotController_GetAnalogInAll:
  code: |
    retval = (self.hal_data['analog_in'],
              self.hal_data['analog_in_raw'],
              self.hal_data['analog_velocity'])
c_MotController_GetQuadratureSensor:
  code: |
    retval = (self.hal_data['quad_position'], self.hal_data['quad_velocity'])
c_MotController_GetPulseWidthAll:
  code: |
    retval = (self.hal_data['pulse_width_position'],
              self.hal_data['pulse_width_velocity'],
              self.hal_data['pulse_width_rise_to_rise'],
              self.hal_data['pulse_width_rise_to_fall'])
c_MotController_GetQuadPinStates:
  code: |
    retval = (self.hal_data['quad_pin_a'],
              self.hal_data['quad_pin_b'],
              self.hal_data['quad_pin_idx'])
c_MotController_GetLimitSwitchState:
  code: |
    retval = self.hal_data['limit_switch_closed_for'], self.hal_data['limit_switch_closed_rev']
  doc: |
    :returns: Forward Limit switch closed, Reverse Limit switch closed
c_MotController_GetClosedLoopTarget:
  code: |
    raise NotImplementedError
  doc: |
    Gets the closed-loop error. The units depend on which control mode is in
    use. See Phoenix-Documentation information on units.

    :param pidIdx:
        0 for Primary closed-loop. 1 for cascaded closed-loop.
    :returns: Closed-loop error value.
